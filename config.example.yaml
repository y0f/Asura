# Asura Configuration
# Copy to config.yaml and adjust values.
# Environment variables can be used: ${VAR_NAME}

server:
  # Address to listen on. Use 127.0.0.1 behind a reverse proxy.
  listen: "127.0.0.1:8090"

  # TLS certificate paths (optional, omit for plain HTTP behind reverse proxy)
  # tls_cert: /path/to/cert.pem
  # tls_key: /path/to/key.pem

  # Request timeouts
  read_timeout: 30s
  write_timeout: 30s
  idle_timeout: 120s

  # Maximum request body size in bytes (default: 1MB)
  max_body_size: 1048576

  # Serve under a sub-path for reverse proxy deployments.
  # Example: base_path: "/asura" → all routes at /asura/...
  # Leave empty or omit to serve from root.
  # base_path: "/asura"

  # Public URL used in notification messages and links.
  # Falls back to http://{listen}{base_path} if unset.
  # external_url: "https://example.com/asura"

  # Trusted reverse proxy IPs or CIDRs.
  # When a request comes from a trusted proxy, Asura reads the real
  # client IP from X-Real-IP or X-Forwarded-For headers.
  # Without this, all requests behind a proxy appear from 127.0.0.1.
  # trusted_proxies:
  #   - "127.0.0.1"
  #   - "::1"
  #   - "10.0.0.0/8"

  # CORS allowed origins (empty = no CORS headers)
  # cors_origins:
  #   - "https://your-app.example.com"

  # Per-IP rate limiting
  rate_limit_per_sec: 10
  rate_limit_burst: 20

  # Enable/disable the web UI (default: true)
  # Set to false for API-only deployments
  web_ui_enabled: true

  # X-Frame-Options / CSP frame-ancestors control
  # [] (empty/default) = DENY — no framing allowed
  # ["self"]           = SAMEORIGIN — only same origin can frame
  # ["self", "https://dashboard.example.com"] = specific origins
  # frame_ancestors: []

database:
  # SQLite database file path
  path: "asura.db"

  # Number of read-only connections (default: number of CPUs)
  max_read_conns: 4

  # How many days to keep check results, incidents, etc.
  retention_days: 90

  # How often to run the retention cleanup
  retention_period: 1h

auth:
  # API keys for authentication.
  # Generate a key+hash pair: asura --setup
  # Or hash an existing key:  asura --hash-key "your-key"
  api_keys:
    - name: "admin"
      hash: "${ASURA_ADMIN_KEY_HASH}"
      role: "admin"          # Full read/write access

    - name: "dashboard"
      hash: "${ASURA_READ_KEY_HASH}"
      role: "readonly"       # Read-only access

  # Session settings for web UI login
  session:
    lifetime: 24h            # How long sessions last (default: 24h)
    cookie_secure: true      # Set Secure flag on cookie (default: true, disable for HTTP-only dev)

  # Login rate limiting (per IP)
  login:
    rate_limit_per_sec: 0.2  # ~1 attempt per 5 seconds sustained
    rate_limit_burst: 5      # Allow 5 rapid attempts before throttling

monitor:
  # Number of concurrent check workers
  workers: 10

  # Default timeout for checks (overridden per-monitor)
  default_timeout: 10s

  # Default check interval (overridden per-monitor)
  default_interval: 60s

  # Number of consecutive failures before opening an incident
  failure_threshold: 3

  # Number of consecutive successes before auto-resolving
  success_threshold: 1

  # Timeout for command-type checks
  command_timeout: 30s

  # How often to check for expired heartbeats
  heartbeat_check_interval: 30s

  # Allow monitors to target private/reserved IPs (default: false)
  # Enable only if you need to monitor internal services (e.g. localhost, 10.x, 192.168.x)
  # allow_private_targets: false

  # Allowlist of command paths (empty = all commands blocked, deny-by-default)
  # command_allowlist:
  #   - /usr/local/bin/check_health
  #   - /opt/scripts/verify

logging:
  # Log level: debug, info, warn, error
  level: "info"

  # Log format: text or json
  format: "text"
