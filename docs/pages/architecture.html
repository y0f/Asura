<h1>Architecture</h1>

<p>Single binary, channel-based pipeline, SQLite storage. Everything talks through Go channels with backpressure.</p>

<h2>Pipeline</h2>

<div class="bg-surface-100 border border-line rounded-lg p-6 mb-6 font-mono text-[13px] text-muted-light overflow-x-auto">
<pre class="!bg-transparent !border-0 !p-0 !mb-0"><code>Scheduler ──▶ Worker Pool ──▶ Result Processor ──▶ Dispatcher
    │              │                 │                   │
 Min-heap      Concurrent       Incidents +        Webhook/Email
 dispatch       Checks         Change Diffs      Telegram/Discord
                                                   Slack/ntfy</code></pre>
</div>

<h2>Scheduler</h2>

<p>A min-heap priority queue ordered by next-due time. Each tick, the scheduler pops all monitors that are due and dispatches them to the worker pool. Dispatch is <strong>O(log n)</strong> per monitor.</p>

<p>When <strong>adaptive intervals</strong> are enabled, the scheduler adjusts timing per monitor:</p>
<ul>
  <li>Stable monitors (60+ consecutive successes) slow to 2x base interval</li>
  <li>Flapping monitors snap to 0.5x for faster detection</li>
  <li>Recovering monitors return to base interval</li>
</ul>

<h2>Worker Pool</h2>

<p>Fixed-size goroutine pool (default 10, set via <code>monitor.workers</code>). Workers pull jobs off the channel, run the protocol checker, measure response time, and evaluate assertions. Bounded channel capacity means the scheduler blocks when all workers are busy.</p>

<h2>Result Processor</h2>

<p>Receives check results from the worker pool. For each result:</p>

<ol>
  <li>Persists the check result to SQLite</li>
  <li>Updates monitor state (status, consecutive counts, response time)</li>
  <li>Evaluates failure/success thresholds for incident transitions</li>
  <li>Computes content diffs if <code>track_changes</code> is enabled</li>
  <li>Publishes events to the dispatcher</li>
</ol>

<h2>Dispatcher</h2>

<p>Routes events to notification channels. Each channel type has its own sender behind the <code>Notifier</code> interface. If a monitor has <code>notification_channel_ids</code> set, only those channels fire. Otherwise all matching channels get the event.</p>

<h2>Storage</h2>

<p>SQLite in WAL mode with separate connection pools:</p>

<ul>
  <li><strong>Write pool</strong>: Single writer protected by <code>writeMu</code> mutex — all INSERT/UPDATE/DELETE go through this</li>
  <li><strong>Read pool</strong>: Multiple concurrent readers via <code>readerPool()</code> — all SELECT queries</li>
</ul>

<p>Reads never block on writes. The <code>Store</code> interface has 141 methods covering everything from monitors to request logs.</p>

<h2>Checker Registry</h2>

<p>Each checker implements <code>Checker</code> with a <code>Check(ctx, monitor)</code> method and gets registered at startup. 11 implementations:</p>

<table>
  <thead>
    <tr><th>Checker</th><th>Protocol</th></tr>
  </thead>
  <tbody>
    <tr><td>HTTP</td><td>HTTP/HTTPS with auth, redirects, TLS verify</td></tr>
    <tr><td>TCP</td><td>TCP connect with send/expect</td></tr>
    <tr><td>DNS</td><td>DNS record queries</td></tr>
    <tr><td>ICMP</td><td>Ping (raw socket or unprivileged)</td></tr>
    <tr><td>TLS</td><td>Certificate expiry checking</td></tr>
    <tr><td>WebSocket</td><td>WS connect with send/expect</td></tr>
    <tr><td>Command</td><td>Execute shell commands</td></tr>
    <tr><td>Docker</td><td>Container state via Docker socket</td></tr>
    <tr><td>Domain</td><td>WHOIS expiry lookups</td></tr>
    <tr><td>gRPC</td><td>gRPC health check protocol</td></tr>
    <tr><td>MQTT</td><td>MQTT 3.1.1 connect + subscribe</td></tr>
  </tbody>
</table>

<h2>Project Structure</h2>

<pre><code>asura/
├── cmd/asura/         # Entry point
├── internal/
│   ├── checker/       # 11 protocol checkers + assertion engine
│   ├── pipeline/      # Scheduler, workers, result processor
│   ├── notifier/      # 6 notification channel senders
│   ├── storage/       # SQLite store (141 methods), migrations
│   ├── server/        # HTTP server, routes, middleware
│   ├── api/           # API handlers (JSON endpoints)
│   ├── web/           # Web UI handlers (template rendering)
│   ├── validate/      # Input validation
│   └── httputil/      # HTTP utilities
├── web/
│   ├── templates/     # HTML templates (layout + feature dirs)
│   └── static/        # CSS, JS, images
├── deploy/            # nginx.conf, Dockerfile, docker-compose
└── docs/              # This documentation site</code></pre>
