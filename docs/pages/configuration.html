<h1>Configuration</h1>

<p>Everything lives in <code>config.yaml</code>. See <a href="https://github.com/y0f/Asura/blob/main/config.example.yaml" target="_blank">config.example.yaml</a> for the full reference. Environment variables expand via <code>${VAR_NAME}</code>.</p>

<h2>Server Settings</h2>

<table>
  <thead>
    <tr><th>Setting</th><th>Default</th><th>Description</th></tr>
  </thead>
  <tbody>
    <tr><td><code>listen</code></td><td><code>127.0.0.1:8090</code></td><td>Address to bind. Keep this localhost-only and put a reverse proxy in front</td></tr>
    <tr><td><code>base_path</code></td><td><code>""</code></td><td>URL prefix for all routes (e.g. <code>/asura</code>)</td></tr>
    <tr><td><code>external_url</code></td><td>auto</td><td>Public URL used in notification links</td></tr>
    <tr><td><code>trusted_proxies</code></td><td><code>[]</code></td><td>IPs/CIDRs whose <code>X-Real-IP</code>/<code>X-Forwarded-For</code> headers are trusted</td></tr>
    <tr><td><code>rate_limit_per_sec</code></td><td><code>10</code></td><td>Per-IP request rate limit</td></tr>
    <tr><td><code>web_ui_enabled</code></td><td><code>true</code></td><td>Serve the web dashboard. Set <code>false</code> to run in API-only mode — all REST endpoints remain available</td></tr>
  </tbody>
</table>

<h2>Authentication</h2>

<p>API keys are hashed with SHA-256 and stored in <code>config.yaml</code>. There's no user registration and no database-stored auth.</p>

<h3>Generating a Key</h3>

<pre><code>./asura --setup</code></pre>

<p>Output:</p>

<pre><code>  API Key : ak_a8f3e7b2c1d9...
  Hash    : fa223e3e1c4b96...

  Put the hash in config.yaml under auth.api_keys[].hash
  Save the API key -- it cannot be recovered.</code></pre>

<p>The <code>ak_</code> prefix makes keys easy to identify in logs without leaking the secret. If you already have a key and just need the hash:</p>

<pre><code>./asura --hash-key "your-secret-key"</code></pre>

<h3>Config</h3>

<pre><code>auth:
  api_keys:
    - name: "admin"
      hash: "2c26b46b68ffc..."
      role: "admin"</code></pre>

<h3>Roles</h3>

<table>
  <thead>
    <tr><th>Role</th><th>Access</th></tr>
  </thead>
  <tbody>
    <tr><td><code>admin</code></td><td>Full read/write access to all resources</td></tr>
    <tr><td><code>readonly</code></td><td>Read-only access (monitors, incidents, notifications, maintenance, metrics)</td></tr>
  </tbody>
</table>

<h3>Custom Permissions</h3>

<p>Instead of a role, grant specific permissions per key:</p>

<pre><code>auth:
  api_keys:
    - name: "ci-bot"
      hash: "..."
      permissions:
        - "monitors.read"
        - "monitors.write"
        - "incidents.read"</code></pre>

<p>Available permissions: <code>monitors.read</code>, <code>monitors.write</code>, <code>incidents.read</code>, <code>incidents.write</code>, <code>notifications.read</code>, <code>notifications.write</code>, <code>maintenance.read</code>, <code>maintenance.write</code>, <code>metrics.read</code>.</p>

<h3>Using a Key</h3>

<p><strong>API</strong>: Pass the raw key (not the hash) in the <code>X-API-Key</code> header:</p>

<pre><code>curl -H "X-API-Key: ak_a8f3e7b2c1d9..." https://example.com/asura/api/v1/monitors</code></pre>

<p><strong>Web UI</strong>: Enter the key on the login page. Asura creates a session cookie (24h, HttpOnly, Secure). Login is rate-limited per IP. You can have multiple keys with different roles or permission sets.</p>

<h2>Monitor Settings</h2>

<table>
  <thead>
    <tr><th>Setting</th><th>Default</th><th>Description</th></tr>
  </thead>
  <tbody>
    <tr><td><code>workers</code></td><td><code>10</code></td><td>Concurrent check workers</td></tr>
    <tr><td><code>default_interval</code></td><td><code>60s</code></td><td>Default check interval for new monitors</td></tr>
    <tr><td><code>default_timeout</code></td><td><code>10s</code></td><td>Default check timeout</td></tr>
    <tr><td><code>adaptive_intervals</code></td><td><code>true</code></td><td>Dynamically adjust check frequency based on monitor stability</td></tr>
  </tbody>
</table>

<h3>Adaptive Intervals</h3>

<p>When enabled, the scheduler adjusts the effective check interval per monitor based on its recent behavior:</p>

<ul>
  <li><strong>Stable monitors</strong> (60+ consecutive successes) gradually slow to 2x their base interval, reducing unnecessary load</li>
  <li><strong>Flapping monitors</strong> (failure after being slowed down) snap back to 0.5x for faster detection</li>
  <li><strong>Recovering monitors</strong> return to the normal base interval until stability is re-established</li>
  <li><strong>Actively failing monitors</strong> stay at the normal base interval</li>
</ul>

<p>The base interval on each monitor is never modified — adaptive intervals only change the scheduler's internal timing. Disable with <code>adaptive_intervals: false</code>.</p>
